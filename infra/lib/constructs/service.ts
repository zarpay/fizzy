import * as cdk from 'aws-cdk-lib';
import * as ecs from 'aws-cdk-lib/aws-ecs';
import * as ec2 from 'aws-cdk-lib/aws-ec2';
import * as secretsmanager from 'aws-cdk-lib/aws-secretsmanager';
import { Construct } from 'constructs';
import { EcrContainerImage, SharedAlbEcsFargateService } from '@zarpay/zar-cdk-lib';
import { config } from '../../environments/config-loader.js';
import { appName, environment, isProduction, smtp } from '../shared/global-variables.js';
import { Database } from './database.js';
import { Storage } from './storage.js';

interface ServiceProps {
  vpc: ec2.IVpc;
  database: Database;
  storage: Storage;
}

export class Service extends Construct {
  constructor(scope: Construct, id: string, props: ServiceProps) {
    super(scope, id);

    // SECRET_KEY_BASE - generated by CDK
    const secretKeyBase = new secretsmanager.Secret(this, 'SecretKeyBase', {
      secretName: `/fizzy/${environment}/secret-key-base`,
      description: 'Rails SECRET_KEY_BASE for Fizzy',
      generateSecretString: {
        excludePunctuation: true,
        passwordLength: 128,
      },
      removalPolicy: isProduction ? cdk.RemovalPolicy.RETAIN : cdk.RemovalPolicy.DESTROY,
    });

    const smtpCredentials = secretsmanager.Secret.fromSecretNameV2(
      this,
      'SmtpCredentials',
      '/platform/smtp/credentials',
    );

    const { image } = EcrContainerImage.fromContext(this, 'FizzyImage', {
      repositoryName: 'fizzy',
    });

    const service = new SharedAlbEcsFargateService(this, 'Service', {
      appName,
      deployEnvironment: environment,
      vpc: props.vpc,
      image,
      validateProductionImageVersion: false,
      autoScaling: {
        minCapacity: config.service.minCapacity,
        maxCapacity: config.service.maxCapacity,
      },
      environment: {
        HTTP_PORT: '3000', // Thruster listens on non-privileged port for Fargate
        TARGET_PORT: '3001', // Puma runs on this port, Thruster proxies to it
        DISABLE_SSL: 'true', // SSL terminated at ALB
        MULTI_TENANT: 'false', // Single-tenant mode: only one account allowed
        BASE_URL: `https://${config.fqdn}`,
        MAILER_FROM_ADDRESS: smtp.fromAddress,
        SMTP_ADDRESS: smtp.address,
        SMTP_PORT: smtp.port.toString(),
        // Database connection
        DATABASE_ADAPTER: 'mysql',
        MYSQL_HOST: props.database.cluster.clusterEndpoint.hostname,
        MYSQL_PORT: props.database.cluster.clusterEndpoint.port.toString(),
        // S3 storage for ActiveStorage
        ...props.storage.environmentVariables,
      },
      secrets: {
        SECRET_KEY_BASE: ecs.Secret.fromSecretsManager(secretKeyBase),
        MYSQL_USER: ecs.Secret.fromSecretsManager(props.database.dbSecret, 'username'),
        MYSQL_PASSWORD: ecs.Secret.fromSecretsManager(props.database.dbSecret, 'password'),
        SMTP_USERNAME: ecs.Secret.fromSecretsManager(smtpCredentials, 'username'),
        SMTP_PASSWORD: ecs.Secret.fromSecretsManager(smtpCredentials, 'password'),
      },
      targetGroupHealthCheck: { path: '/up' },
      dns: {
        zoneName: config.hostedZoneName,
        recordName: config.fqdn,
        // TODO: Remove after DNS propagation - will become primary domain
        additionalDomains: [
          { zoneName: 'zarhq.dev', recordName: 'fizzy.zarhq.dev' },
        ],
      },
    });

    // Grant S3 permissions to the ECS task role
    props.storage.grantReadWrite(service.taskDefinition.taskRole);
  }
}
